
TermProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000001e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000170  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000d  00800100  00800100  000001e4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000001e4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000214  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000090  00000000  00000000  00000254  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000b47  00000000  00000000  000002e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007af  00000000  00000000  00000e2b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000005b2  00000000  00000000  000015da  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000108  00000000  00000000  00001b8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000424  00000000  00000000  00001c94  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000243  00000000  00000000  000020b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000070  00000000  00000000  000022fb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   8:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  10:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  14:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  18:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  1c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  20:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  24:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  28:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  2c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  30:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  34:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  38:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  3c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  40:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  44:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  48:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  4c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  50:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  54:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  58:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  5c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  60:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  64:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
  74:	21 e0       	ldi	r18, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
  7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
  7e:	ad 30       	cpi	r26, 0x0D	; 13
  80:	b2 07       	cpc	r27, r18
  82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
  84:	0e 94 60 00 	call	0xc0	; 0xc0 <main>
  88:	0c 94 b6 00 	jmp	0x16c	; 0x16c <_exit>

0000008c <__bad_interrupt>:
  8c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000090 <writeColor>:
    }
}

//Writes a color to the color buffer and increments cIndex.
void writeColor(uint8_t red, uint8_t green, uint8_t blue) {
	redVals[cIndex] = red;
  90:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
  94:	29 2f       	mov	r18, r25
  96:	30 e0       	ldi	r19, 0x00	; 0
  98:	f9 01       	movw	r30, r18
  9a:	eb 5f       	subi	r30, 0xFB	; 251
  9c:	fe 4f       	sbci	r31, 0xFE	; 254
  9e:	80 83       	st	Z, r24
	greenVals[cIndex] = green;
  a0:	f9 01       	movw	r30, r18
  a2:	e7 5f       	subi	r30, 0xF7	; 247
  a4:	fe 4f       	sbci	r31, 0xFE	; 254
  a6:	60 83       	st	Z, r22
	blueVals[cIndex] = blue;
  a8:	f9 01       	movw	r30, r18
  aa:	ef 5f       	subi	r30, 0xFF	; 255
  ac:	fe 4f       	sbci	r31, 0xFE	; 254
  ae:	40 83       	st	Z, r20
	cIndex = (cIndex >= 4) ? 0 : cIndex + 1; //Increment cIndex unless it is at (or above) 7, then set it to 0.
  b0:	94 30       	cpi	r25, 0x04	; 4
  b2:	10 f4       	brcc	.+4      	; 0xb8 <writeColor+0x28>
  b4:	9f 5f       	subi	r25, 0xFF	; 255
  b6:	01 c0       	rjmp	.+2      	; 0xba <writeColor+0x2a>
  b8:	90 e0       	ldi	r25, 0x00	; 0
  ba:	90 93 00 01 	sts	0x0100, r25	; 0x800100 <__DATA_REGION_ORIGIN__>
  be:	08 95       	ret

000000c0 <main>:
void updateLED(void);

int main(void)
{
	//Initialization:
	for (uint8_t i = 0; i < 4; i++) writeColor(0, 0, 0); //Clear the color buffer so the LEDs don't display incorrect data.
  c0:	c0 e0       	ldi	r28, 0x00	; 0
  c2:	06 c0       	rjmp	.+12     	; 0xd0 <main+0x10>
  c4:	40 e0       	ldi	r20, 0x00	; 0
  c6:	60 e0       	ldi	r22, 0x00	; 0
  c8:	80 e0       	ldi	r24, 0x00	; 0
  ca:	0e 94 48 00 	call	0x90	; 0x90 <writeColor>
  ce:	cf 5f       	subi	r28, 0xFF	; 255
  d0:	c4 30       	cpi	r28, 0x04	; 4
  d2:	c0 f3       	brcs	.-16     	; 0xc4 <main+0x4>
	
	i2c_start(SENSOR_ADDR+I2C_WRITE);
  d4:	88 e3       	ldi	r24, 0x38	; 56
  d6:	0e 94 76 00 	call	0xec	; 0xec <i2c_start>
	i2c_write(0x00);
  da:	80 e0       	ldi	r24, 0x00	; 0
  dc:	0e 94 a4 00 	call	0x148	; 0x148 <i2c_write>
	i2c_write(0x01); //Tell the color sensor to turn on.
  e0:	81 e0       	ldi	r24, 0x01	; 1
  e2:	0e 94 a4 00 	call	0x148	; 0x148 <i2c_write>
	i2c_stop();
  e6:	0e 94 9c 00 	call	0x138	; 0x138 <i2c_stop>
  ea:	ff cf       	rjmp	.-2      	; 0xea <main+0x2a>

000000ec <i2c_start>:
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
    return i2c_start( address );

}/* i2c_rep_start */
  ec:	94 ea       	ldi	r25, 0xA4	; 164
  ee:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
  f2:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
  f6:	99 23       	and	r25, r25
  f8:	e4 f7       	brge	.-8      	; 0xf2 <i2c_start+0x6>
  fa:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
  fe:	98 7f       	andi	r25, 0xF8	; 248
 100:	98 30       	cpi	r25, 0x08	; 8
 102:	11 f0       	breq	.+4      	; 0x108 <i2c_start+0x1c>
 104:	90 31       	cpi	r25, 0x10	; 16
 106:	91 f4       	brne	.+36     	; 0x12c <i2c_start+0x40>
 108:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
 10c:	84 e8       	ldi	r24, 0x84	; 132
 10e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 112:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 116:	88 23       	and	r24, r24
 118:	e4 f7       	brge	.-8      	; 0x112 <i2c_start+0x26>
 11a:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
 11e:	88 7f       	andi	r24, 0xF8	; 248
 120:	88 31       	cpi	r24, 0x18	; 24
 122:	31 f0       	breq	.+12     	; 0x130 <i2c_start+0x44>
 124:	80 34       	cpi	r24, 0x40	; 64
 126:	31 f4       	brne	.+12     	; 0x134 <i2c_start+0x48>
 128:	80 e0       	ldi	r24, 0x00	; 0
 12a:	08 95       	ret
 12c:	81 e0       	ldi	r24, 0x01	; 1
 12e:	08 95       	ret
 130:	80 e0       	ldi	r24, 0x00	; 0
 132:	08 95       	ret
 134:	81 e0       	ldi	r24, 0x01	; 1
 136:	08 95       	ret

00000138 <i2c_stop>:
 Terminates the data transfer and releases the I2C bus
*************************************************************************/
void i2c_stop(void)
{
    /* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 138:	84 e9       	ldi	r24, 0x94	; 148
 13a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	
	// wait until stop condition is executed and bus released
	while(TWCR & (1<<TWSTO));
 13e:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 142:	84 fd       	sbrc	r24, 4
 144:	fc cf       	rjmp	.-8      	; 0x13e <i2c_stop+0x6>

}/* i2c_stop */
 146:	08 95       	ret

00000148 <i2c_write>:
unsigned char i2c_write( unsigned char data )
{	
    uint8_t   twst;
    
	// send data to the previously addressed device
	TWDR = data;
 148:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
	TWCR = (1<<TWINT) | (1<<TWEN);
 14c:	84 e8       	ldi	r24, 0x84	; 132
 14e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 152:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 156:	88 23       	and	r24, r24
 158:	e4 f7       	brge	.-8      	; 0x152 <i2c_write+0xa>

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
 15a:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
 15e:	88 7f       	andi	r24, 0xF8	; 248
	if( twst != TW_MT_DATA_ACK) return 1;
 160:	88 32       	cpi	r24, 0x28	; 40
 162:	11 f0       	breq	.+4      	; 0x168 <i2c_write+0x20>
 164:	81 e0       	ldi	r24, 0x01	; 1
 166:	08 95       	ret
	return 0;
 168:	80 e0       	ldi	r24, 0x00	; 0

}/* i2c_write */
 16a:	08 95       	ret

0000016c <_exit>:
 16c:	f8 94       	cli

0000016e <__stop_program>:
 16e:	ff cf       	rjmp	.-2      	; 0x16e <__stop_program>
